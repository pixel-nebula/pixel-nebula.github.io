<html lang="en">
<head>
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <meta http-equiv="Content-Security-Policy" content="frame-ancestors 'none';">
  <script src="https://cdn.jsdelivr.net/gh/pixel-nebula/pixel-nebula.github.io@master/particles.js"></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PixelNebula</title>
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/pixel-nebula/pixel-nebula.github.io@master/Pictures/Logo.png" type="image/png">
<style>
body {
  font-family: 'Varela Round', sans-serif;
  margin: 0;
  padding: 0;
  background-color: #000000;
}
.logo {
  width: 50px;
  height: 50px;
  margin-right: 10px;
}
.container {
  max-width: 800px;
  margin: 150px auto 0 auto;
  padding: 20px;
  text-align: center;
  background: transparent;
  color: white;
  border: 5px solid white;
  border-radius: 25px;
  z-index: 999989;
}
select {
  font-family: 'Varela Round', sans-serif;
  color: #fff;
  background-color: #ffff;
  margin-bottom: 10px;
  padding: 10px;
  font-size: 16px;
  border: 5px solid white;
  border-radius: 10px;
  width: 100%;
  z-index: 999999;
}
button {
  font-family: 'Varela Round', sans-serif;
  background-color: #000000;
  color: #fff;
  padding: 10px 20px;
  font-size: 16px;
  cursor: pointer;
  margin-top: 10px;
  transition: background-color 0.3s ease;
  border: 5px solid white;
  border-radius: 10px;
  z-index: 999999;
}
button:hover {
  background-color: #3C3C3C;
}
.overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  color: #fff;
  font-size: 24px;
  user-select: none;
  flex-direction: column;
  z-index: 999999;
}
.spinner {
  border: 6px solid rgba(255, 255, 255, 0.3);
  border-top: 6px solid #fff;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin-bottom: 20px;
  z-index: 999999;
}
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
#killExtensionText {
  display: none;
  margin-top: 20px;
  color: #333;
  font-size: 18px;
  text-align: center;
  background: #e9ecef;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  z-index: 999999;
}
#killButton {
  display: none;
  background-color: #dc3545;
  color: #fff;
  border: none;
  padding: 10px 20px;
  font-size: 16px;
  cursor: pointer;
  border-radius: 5px;
  transition: background-color 0.3s ease;
  z-index: 999999;
}
#killButton:hover {
  background-color: #9c1c28;
}
.header {
            margin-top: 20px;
            text-align: center;
        }
        .header h1 {
            font-size: 60px;
            margin: 0;
        }
        .header h2 {
            font-size: 40px;
            margin: 0;
        }
        .menu {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 20px; /* Adjust the spacing betwe menu items */
        }
        .menu a {
            text-decoration: none;
            color: white;
            font-size: 16px;
            font-weight: bold;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        .menu a:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        .menu a.Games {
            text-decoration: underline;
        }
        .logout {
            position: absolute;
            top: 20px; /* Top right of the window */
            right: 20px;
            padding: 10px;
            text-decoration: none;
            color: white;
            font-size: 16px;
            font-weight: bold;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .logout:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        .profile {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .profile img {
            border-radius: 50%;
            width: 40px;
            height: 40px;
            transition: transform 0.3s ease;
        }

        .profile:hover img {
            transform: scale(1.1);
        }

        .dropdown {
            display: none;
            position: absolute;
            top: 60px; /* Positioning the dropdown below the profile image */
            right: 0;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }

        .dropdown a {
            display: block;
            text-decoration: none;
            color: white;
            font-size: 16px;
            font-weight: bold;
            padding: 10px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .dropdown a:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        #particles-js {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0; /* Send it behind all other elements */
        }
        .message-box {
  position: fixed;
  bottom: 10px;
  right: 10px;
  background-color: rgba(0, 0, 0, 0.3); /* Half-transparent black */
  color: white;
  padding: 15px;
  font-size: 14px;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  width: auto;
  max-width: 300px;
}

.message-box a {
  color: #00b0ff;
  text-decoration: none;
}

.message-box a:hover {
  text-decoration: underline;
}
.close-btn {
  position: absolute;
  top: 5px;
  left: 5px;
  cursor: pointer;
  font-size: 20px;
  font-weight: bold;
  color: #fff;
}

.close-btn:hover {
  color: red;
}
:root {
        --clr1: #00ff00; /* Green color for text */
    }


    .drops {
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        font-size: 2em;
        white-space: nowrap;
        color: var(--clr1); /* Green color */
        font-weight: bold;
        z-index: 0;
        background: transparent;
        padding: 10px 25px;
        transition: background-color 0.5s;
    }

    .drop {
    position: absolute;
    color: var(--clr1); /* Green color */
    font-size: 1.5em; /* Smaller text size */
    top: 0;
    animation: none;
    transition: color 0.5s;
    z-index: -1; /* Send the drops to the background */
}


    @keyframes drop-fall {
        0% {
            transform: translateY(0); /* Start at the top */
            opacity: 1;
        }
        100% {
            transform: translateY(100vh); /* Fall all the way to the bottom */
            opacity: 0; /* Fade out */
        }
    }
    #LaserCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;  /* Ensure it's on top of other elements */
    pointer-events: auto;  /* Allow click-through */
}
#dotCanvas {
            display: block;
            position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;  /* Ensure it's on top of other elements */
    pointer-events: auto;  /* Allow click-through */
        }
</style>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6845450223326411"crossorigin="anonymous"></script>
</head>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C130NKT3ZP');
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C130NKT3ZP"></script>
<body onload="checkLoginStatus()">
  <div style="visibility: hidden;" id="particles-js"></div>
    <div style="visibility: hidden;" id="drops"></div>
    <canvas style="visibility: hidden;"  id="LaserCanvas"></canvas>
    <canvas style="visibility: hidden;" id="dotCanvas"></canvas>
    <!-- Menu -->
    <div class="menu">
        <a href="Home.html">Home</a>
        <a href="Games.html">Games</a>
        <a href="Apps.html">Apps</a>
    </div>
    
    <div class="profile" onclick="toggleDropdown()">
        <img id="profile-pic" src="https://cdn.jsdelivr.net/gh/pixel-nebula/pixel-nebula.github.io@master/Pictures/profilepic.jpg" alt="Profile">
        <div class="dropdown" id="dropdown-menu">
            <a href="Settings.html">Settings</a>
            <a href="#" onclick="logout()">Logout</a>
        </div>
    </div>
<div class="container">
  <p>Welcome to Pixel Crasher! lag after you finish shattering is normal.</p>

  <label for="iframeSelect" id="labelForIframeSelect"></label>
  <select style="background-color: #000000; color: #fff;" id="iframeSelect"></select>
  
  
  <label for="iframeCountSlider" id="labelForIframeSlider" style="margin-top: 20px;">The slider below changes the crashing value. The time unblocking goes up but it might cause more lag.</label>

  <div style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
    <input type="range" id="iframeCountSlider" min="100" max="15000" value="2000" step="100" style="flex-grow: 1;">
    <span id="iframeCountValue">3000</span>
  </div>

  <button onclick="warning();" id="hangButton">Shatter Extension!</button>
  <button id="killButton" onclick="openExtensionPopup();">Kill Extension!</button>
</div>

<div class="overlay" id="overlay"><div class="spinner"></div> Shattering... (This will take a few minutes)</div>

<div id="killExtensionText"></div>

<script>
document.addEventListener("DOMContentLoaded", function() {
  const slider = document.getElementById("iframeCountSlider");
  const sliderValueDisplay = document.getElementById("iframeCountValue");
  const deviceMemory = navigator.deviceMemory || 8;
  const defaultIframeCount = Math.round(deviceMemory * 500);
  const maxIframeCount = Math.round(deviceMemory * 10000);
  slider.value = defaultIframeCount;
  slider.max = maxIframeCount;
  sliderValueDisplay.textContent = defaultIframeCount;
  
  slider.addEventListener("input", function() {
    sliderValueDisplay.textContent = this.value;
  });
});

document.getElementById("iframeCountSlider").addEventListener("input", function() {
  const iframeCountValue = document.getElementById("iframeCountValue");
  iframeCountValue.textContent = this.value;
});

async function checkExtensionURL(url) {
  try {
    const response = await fetch(url);
    return response.ok;
  } catch (error) {
    return false;
  }
}

async function populateSelectOptions() {
  const selectElement = document.getElementById("iframeSelect");
  const extensions = {
    "Lightspeed Filter Agent": "chrome-extension://adkcpkpghahmbopkjchobieckeoaoeem/icon-128.png",
    "Lightspeed Insight Agent": "chrome-extension://njdniclgegijdcdliklgieicanpmcngj/js/wasm_exec.js",
    "Classroom": "chrome-extension://kkbmdgjggcdajckdlbngdjonpchpaiea/assets/icon-classroom-128.png"
  };

  let hasSupportedExtensions = false;
  for (const [name, url] of Object.entries(extensions)) {
    if (await checkExtensionURL(url)) {
      const option = document.createElement("option");
      option.value = url;
      option.textContent = name;
      selectElement.appendChild(option);
      hasSupportedExtensions = true;
    }
  }
  if (!hasSupportedExtensions) {
    const option = document.createElement("option");
    option.value = "";
    option.textContent = "No supported extensions installed";
    selectElement.appendChild(option);
    document.getElementById("hangButton").style.display = "none";
    document.getElementById("iframeCountSlider").style.display = "none";
    try { document.getElementById("labelForIframeSlider").style.display = "none"; } catch (err) {}
    document.getElementById("iframeCountValue").style.display = "none";
  }
}
populateSelectOptions();

function replaceIframes(container, iframeSrc, iframeCount) {
  for (let i = 0; i < iframeCount; i++) {
    const iframe = document.createElement('iframe');
    iframe.src = iframeSrc;
    iframe.style.width = '100%';
    iframe.style.height = '100px';
    container.appendChild(iframe);
  }
  setTimeout(function() {
    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }
    replaceIframes(container, iframeSrc, iframeCount);
  }, 5);
}

function warning() {
  const overlay = document.getElementById("overlay");
  overlay.style.display = "flex";
  const ContainerGeneral = document.getElementById("container")
  ContainerGeneral.style.display = "none";
  const iframeSelect = document.getElementById("iframeSelect");
  const selectedOption = iframeSelect.options[iframeSelect.selectedIndex].text;
  const selectedSrc = iframeSelect.value;
  const iframeCount = parseInt(document.getElementById("iframeCountSlider").value, 10);
  const popup = window.open("", "PopupWindow", "width=100,height=100");
  const popupDocument = popup.document;
  const popupBody = popupDocument.body;
  const iframeContainer = popupDocument.createElement('div');
  iframeContainer.id = 'iframeContainer';
  popupBody.appendChild(iframeContainer);
  replaceIframes(iframeContainer, selectedSrc, iframeCount);

  setTimeout(function() {
    popup.close();
    const ContainerGeneral = document.getElementById("container")
    ContainerGeneral.style.display = "flex";
    const killExtensionText = document.getElementById("killExtensionText");
    killExtensionText.innerHTML = "Now that the extension <strong>" + selectedOption + "</strong> has been Crashed, press the button above.";
    setTimeout(function() {
      overlay.style.display = "none";
      killExtensionText.style.display = "block";
      document.getElementById("killButton").style.display = "inline-block";
      document.getElementById("hangButton").style.display = "none";
      document.getElementById("iframeSelect").style.display = "none";
      try { document.getElementById("labelForIframeSelect").style.display = "none"; } catch (err) {}
      document.getElementById("iframeCountSlider").style.display = "none";
      document.getElementById("iframeCountValue").style.display = "none";
      document.getElementById("killButton").setAttribute("data-url", selectedSrc);
    }, 10000);
  }, 5000);
}

function openExtensionPopup() {
  const selectedSrc = document.getElementById("killButton").getAttribute("data-url");
  const extensionId = selectedSrc.substring(selectedSrc.indexOf("//") + 2, selectedSrc.indexOf("/", selectedSrc.indexOf("//") + 2));
  const killExtensionText = document.getElementById("killExtensionText");
  document.getElementById("killButton").style.display = "none";
  killExtensionText.innerHTML = "Make sure to keep this tab open. Then open <strong>chrome://extensions/?id=" + extensionId + "</strong> and flip the switch called 'Allow access to file URLs' twice. The extension was successfully killed! Now you can close that tab as well as this one. If you want to restore the extension, restart your computer.";
  window.location.href = selectedSrc;
}
</script>
</body>
</html>
<script>
  function isGoogleIDToken(token) {const jwtPattern = /^[a-zA-Z0-9\-_]+\.([a-zA-Z0-9\-_]+)\.[a-zA-Z0-9\-_]+$/; return jwtPattern.test(token);}

    function checkLoginStatus() {
        if (!navigator.onLine) {

          const idToken = getCookie('IDToken'); 
        if (!idToken || !isGoogleIDToken(idToken)) {window.location.href = 'index.html';}

        let cookieName = 'backgroundtype';
let cookieValue = getCookie(cookieName);

// If cookie value exists, apply the visibility based on the value
if (cookieValue === '1') {
document.getElementById('particles-js').style.visibility = 'visible';
} else if (cookieValue === '2') {
document.getElementById('drops').style.visibility = 'visible';
} else if (cookieValue === '3') {
document.getElementById('LaserCanvas').style.visibility = 'visible';
} else if (cookieValue === '4') {
document.getElementById('dotCanvas').style.visibility = 'visible';
} else {
// If no cookie exists, set the cookie to '1' and set the default visibility
setCookie(cookieName, '1', 100);  // Set the default cookie value
document.getElementById('particles-js').style.visibility = 'visible';
}
        document.body.style.visibility = "visible";
        document.getElementById('profile-pic').src = 'https://cdn.jsdelivr.net/gh/pixel-nebula/pixel-nebula.github.io@master/Pictures/profilepic.jpg';
        document.getElementById("messageBox").style.display = "none";
        const gameItems = document.querySelectorAll('.game-item');

    gameItems.forEach(item => {
        // Update the play button
        const playButton = item.querySelector('.play-button');
        playButton.href = "#";
        playButton.textContent = "Unavailable";

        // Update the status message
        const statusMessage = item.querySelector('.text-container p small');
        if (statusMessage) {
            statusMessage.textContent = "Offline";
        }
    });
        }
        else if (navigator.onLine) {
          let cookieName = 'backgroundtype';
let cookieValue = getCookie(cookieName);

// If cookie value exists, apply the visibility based on the value
if (cookieValue === '1') {
document.getElementById('particles-js').style.visibility = 'visible';
} else if (cookieValue === '2') {
document.getElementById('drops').style.visibility = 'visible';
} else if (cookieValue === '3') {
document.getElementById('LaserCanvas').style.visibility = 'visible';
} else if (cookieValue === '4') {
document.getElementById('dotCanvas').style.visibility = 'visible';
} else {
// If no cookie exists, set the cookie to '1' and set the default visibility
setCookie(cookieName, '1', 100);  // Set the default cookie value
document.getElementById('particles-js').style.visibility = 'visible';
}
const cookies = document.cookie.split(';').reduce((acc, cookie) => {
    const [key, value] = cookie.split('=').map(c => c.trim());
    acc[key] = value;
    return acc;
}, {});

const idToken = cookies.IDToken;

if (idToken) {
    if (sessionStorage.getItem('profile-pic')) {
        // Use cached profile pic if available
        document.getElementById('profile-pic').src = sessionStorage.getItem('profile-pic');
        document.body.style.visibility = "visible";
    } else {
        // Fetch profile info from API
        fetch(`https://www.googleapis.com/oauth2/v3/tokeninfo?id_token=${idToken}`)
            .then(response => response.json())
            .then(data => {
                document.getElementById('profile-pic').src = data.picture;
                // Cache profile picture in sessionStorage
                sessionStorage.setItem('profile-pic', data.picture);
                document.body.style.visibility = "visible";
            })
            .catch(error => {
                console.error('Error validating token:', error);
                document.cookie = "IDToken=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/";
                window.location.href = 'index.html';
            });
    }
} else {
    window.location.href = 'index.html';
}

if (getCookie("messageBoxClosed") === "true") {document.getElementById("messageBox").style.display = "none";}
document.getElementById('profile-pic').onerror = function() {
    this.src = 'https://cdn.jsdelivr.net/gh/pixel-nebula/pixel-nebula.github.io@master/Pictures/profilepic.jpg';  // Path to your default profile picture
};
}

    function logout() {
        document.cookie = "IDToken=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/";
        window.location.href = 'index.html';
    }

    document.getElementById('searchInput').addEventListener('input', function() {
        let filter = this.value.toLowerCase();
        let gameItems = document.querySelectorAll('.game-item');
        
        gameItems.forEach(function(item) {
            let gameTitle = item.querySelector('h3').textContent.toLowerCase();
            if (gameTitle.includes(filter)) {
                item.style.display = '';
            } else {
                item.style.display = 'none';
            }
        });
    });
    }
</script>
<script src="Laser.js"></script>
<script>
  particlesJS('particles-js', {
      "particles": {
"number": {
"value": 200,
"density": {
  "enable": true,
  "value_area": 800
}
},
"color": {
"value": "#ffffff"
},
"shape": {
"type": "", // Circle //
"stroke": {
  "width": 0,
  "color": "#000000"
},
"polygon": {
  "nb_sides": 5
},
"image": {
  "src": "img/github.svg",
  "width": 100,
  "height": 100
}
},
"opacity": {
"value": 1,
"random": true,
"anim": {
  "enable": true,
  "speed": 1,
  "opacity_min": 0,
  "sync": false
}
},
"size": {
"value": 3,
"random": true,
"anim": {
  "enable": false,
  "speed": 4,
  "size_min": 0.3,
  "sync": false
}
},
"line_linked": {
"enable": true,
"distance": 90,
"color": "#ffffff",
"opacity": 0.4,
"width": 1
},
"move": {
"enable": true,
"speed": 2,
"direction": "none",
"random": true,
"straight": false,
"out_mode": "out",
"bounce": false,
"attract": {
  "enable": false,
  "rotateX": 600,
  "rotateY": 600
}
}
},
"interactivity": {
"detect_on": "canvas",
"events": {
"onhover": {
  "enable": true,
  "mode": "repulse"
},
"onclick": {
  "enable": false,
  "mode": "repulse"
},
"resize": true
},
"modes": {
"grab": {
  "distance": 400,
  "line_linked": {
    "opacity": 1
  }
},
"bubble": {
  "distance": 100,
  "size": 4,
  "duration": 2,
  "opacity": 0,
  "speed": 3
},
"repulse": {
  "distance": 50,
  "duration": 0.4
},
"push": {
  "particles_nb": 4
},
"remove": {
  "particles_nb": 2
}
}
},
"retina_detect": true
  });
</script>

<script>
  function closeMessageBox() {
  document.getElementById("messageBox").style.display = "none";
  setCookie("messageBoxClosed", "true", 5); // Cookie expires in 30 days
}


function setCookie(name, value, days) {
  const date = new Date();
  date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
  const expires = "expires=" + date.toUTCString();
  document.cookie = name + "=" + value + ";" + expires + ";path=/";
}

// Function to get a cookie by its name.
function getCookie(name) {
  const nameEq = name + "=";
  const ca = document.cookie.split(';');
  for (let i = 0; i < ca.length; i++) {
    let c = ca[i].trim();
    if (c.indexOf(nameEq) == 0) return c.substring(nameEq.length, c.length);
  }
  return "";
}
</script>

<script>
  function getCookie(name) {
          // Split document.cookie into individual cookies
          let decodedCookie = decodeURIComponent(document.cookie);
          let cookies = decodedCookie.split(';');
          for (let i = 0; i < cookies.length; i++) {
              let cookie = cookies[i].trim();
              // Check if the cookie starts with the name we're looking for
              if (cookie.startsWith(name + '=')) {
                  return cookie.substring(name.length + 1); // Return the value of the cookie
              }
          }
          return ''; // Return empty string if cookie is not found
      }

      function setCookie(name, value, days) {
          let expires = '';
          if (days) {
              let date = new Date();
              date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000)); // Set expiration time
              expires = "; expires=" + date.toUTCString();
          }
          document.cookie = name + "=" + value + expires + "; path=/"; // Set the cookie
      }

  const colors = ['#00ff00']; // Green color for all letters
  let colorIndex = 0;

  function updateColor() {
      const currentColor = colors[colorIndex];
      document.documentElement.style.setProperty('--clr1', currentColor);
      const drops = document.querySelectorAll('.drop');
      drops.forEach(drop => {
          drop.style.color = currentColor;
      });
      colorIndex = (colorIndex + 1) % colors.length;
  }

  updateColor();
  setInterval(updateColor, 1000);

  function createFallingDropWithDelay(content) {
    const drop = document.createElement('div');
    drop.classList.add('drop');
    drop.textContent = content;

    // Random position at the top, but not too close to the edges (at least 10px away)
    const randomLeft = Math.random() * (100 - 10) + 5; // Random position between 10px and 90% of the screen width
    drop.style.left = `${randomLeft}%`;

    document.getElementById('drops').appendChild(drop);

    setTimeout(() => {
        drop.style.animation = 'drop-fall 3s linear forwards'; // Fall down
    }, 100);

    setTimeout(() => {
        drop.remove(); // Remove after animation ends
    }, 2900); // Remove after 3 seconds
}


  function generateSourceDrop() {
      const symbolsPerTick = 1; // Spawn fewer symbols (1 symbol per tick)
      for (let i = 0; i < symbolsPerTick; i++) {
          const content = ['@', '#', '$', '%', '&', '*'][Math.floor(Math.random() * 6)];
          createFallingDropWithDelay(content);
      }
  }

  setInterval(generateSourceDrop, 60); // Adjusted interval to spawn fewer drops
</script>
<script>
  function toggleDropdown() {
  const dropdown = document.getElementById('dropdown-menu');
  dropdown.style.display = (dropdown.style.display === 'block') ? 'none' : 'block';
}

        function logout() {
            document.cookie = "IDToken=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/";
            window.location.href = 'index.html';
        }

        // Close dropdown if clicking outside the profile
        window.onclick = function(event) {
            if (!event.target.matches('.profile img')) {
                const dropdown = document.getElementById('dropdown-menu');
                if (dropdown.style.display === 'block') {
                    dropdown.style.display = 'none';
                }
            }
          }
</script>
<script>
  const canvasDot2 = document.getElementById('dotCanvas');
const ctx22 = canvasDot2.getContext('2d');
const word2 = "PXL NB";  // Single word
let dots2 = [];
let mouseX2 = 0, mouseY2 = 0;

// Set canvas size
canvasDot2.width = window.innerWidth;
canvasDot2.height = window.innerHeight;

// Dot class to represent a moving dot
class Dot2 {
    constructor(x, y, targetX, targetY) {
        this.x = x;
        this.y = y;
        this.targetX = targetX;
        this.targetY = targetY;
        this.easing = 0.05;  // Easing factor (slow movement)
        this.size = 4; // Size of the dot
        this.repulsionDistance = 100; // Distance for mouse repulsion
        this.repulsionStrength = 0.1; // Repulsion strength
    }

    // Move the dot smoothly to its target position
    move() {
        // Repulsion from the mouse if too close
        const dx = mouseX2 - this.x;
        const dy = mouseY2 - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < this.repulsionDistance) {
            // Apply repulsion
            const repulsionForce = (this.repulsionDistance - distance) * this.repulsionStrength;
            this.x -= repulsionForce * (dx / distance);
            this.y -= repulsionForce * (dy / distance);
        } else {
            // Apply attraction to the original position
            this.x += (this.targetX - this.x) * this.easing;
            this.y += (this.targetY - this.y) * this.easing;
        }
    }

    draw() {
        ctx22.beginPath();
        ctx22.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx22.fillStyle = '#fff';
        ctx22.fill();
    }

    // Update the target position
    updateTarget(newTargetX, newTargetY) {
        this.targetX = newTargetX;
        this.targetY = newTargetY;
    }
}

// Function to create dots for a given word
function createDotsForWord2(word) {
    const tempCanvas2 = document.createElement('canvas');
    const tempCtx2 = tempCanvas2.getContext('2d');
    tempCanvas2.width = canvasDot2.width;
    tempCanvas2.height = canvasDot2.height;

    // Calculate the font size to make the word fit almost perfectly within the canvas
    const fontSize2 = Math.min(canvasDot2.width / (word.length * 1), canvasDot2.height / 1); // Adjust size based on screen size
    tempCtx2.font = `bold ${fontSize2}px Arial`;
    tempCtx2.fillStyle = '#ffffff';
    tempCtx2.textAlign = 'left';
    tempCtx2.textBaseline = 'top';
    tempCtx2.clearRect(0, 0, tempCanvas2.width, tempCanvas2.height);

    // Calculate the word's position in the middle
    const wordWidth2 = tempCtx2.measureText(word).width;
    const wordHeight2 = fontSize2;  // Approximate height of the word
    const startX2 = canvasDot2.width / 2 - wordWidth2 / 2;
    const startY2 = canvasDot2.height / 2 - wordHeight2 / 2;

    tempCtx2.clearRect(0, 0, tempCanvas2.width, tempCanvas2.height);
    tempCtx2.fillText(word, startX2, startY2);

    // Get image data for the word
    const imageData2 = tempCtx2.getImageData(0, 0, tempCanvas2.width, tempCanvas2.height);
    const dots2 = [];

    // Loop through all the pixels and create dots where there's non-transparent color
    let totalDots2 = 0;
    for (let y = 0; y < imageData2.height; y += 6) {  // Reduced spacing to create more dots
        for (let x = 0; x < imageData2.width; x += 6) {  // Reduced spacing to create more dots
            const i = (y * imageData2.width + x) * 4;
            const a = imageData2.data[i + 3];

            // If the pixel is not transparent (alpha > 128), create a dot
            if (a > 128) {
                // Scatter the dots slightly around their original target positions for less uniformity
                const offsetX2 = (Math.random() - 0.5) * 5;
                const offsetY2 = (Math.random() - 0.5) * 5;

                // Add the dot only if it doesn't overlap with an existing one
                let overlaps2 = false;
                for (let dot of dots2) {
                    const dist = Math.sqrt((dot.x - (x + offsetX2)) ** 2 + (dot.y - (y + offsetY2)) ** 2);
                    if (dist < dot.size * 2) {  // If the dot is too close to another
                        overlaps2 = true;
                        break;
                    }
                }

                if (!overlaps2) {
                    const dot = new Dot2(x + offsetX2, y + offsetY2, x + offsetX2, y + offsetY2);
                    dots2.push(dot);
                    totalDots2++;
                }

                // Limit the number of dots to 200 per letter
                if (totalDots2 >= word.length * 500) break;
            }
        }
        if (totalDots2 >= word.length * 500) break;
    }

    return dots2;
}

// Function to animate the dots
function animate2() {
    ctx22.clearRect(0, 0, canvasDot2.width, canvasDot2.height); // Clear the canvas
    dots2.forEach(dot => {
        dot.move();
        dot.draw();
    });
    requestAnimationFrame(animate2);
}

// Initialize setup
dots2 = createDotsForWord2(word2);
animate2();

// Handle mouse movement
window.addEventListener('mousemove', (e) => {
    mouseX2 = e.clientX;
    mouseY2 = e.clientY;
});

// Adjust canvas size when window is resized
window.addEventListener('resize', () => {
    canvasDot2.width = window.innerWidth;
    canvasDot2.height = window.innerHeight;
    dots2 = createDotsForWord2(word2);
});

</script>